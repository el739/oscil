/*
 * ili9341.c
 *
 *  Created on: Dec 4, 2025
 *      Author: 20817
 */
// ili9341.c
#include "ili9341.h"

static uint16_t _width = ILI9341_WIDTH;
static uint16_t _height = ILI9341_HEIGHT;

static const uint8_t font5x7[] = {
    0x00,0x00,0x00,0x00,0x00, 0x3E,0x5B,0x4F,0x5B,0x3E, 0x3E,0x6B,0x4F,0x6B,0x3E, 0x1C,0x3E,0x7C,0x3E,0x1C,
    0x18,0x3C,0x7E,0x3C,0x18, 0x1C,0x57,0x7D,0x57,0x1C, 0x1C,0x5E,0x7F,0x5E,0x1C, 0x00,0x18,0x3C,0x18,0x00,
    0xFF,0xE7,0xC3,0xE7,0xFF, 0x00,0x18,0x24,0x18,0x00, 0xFF,0xE7,0xDB,0xE7,0xFF, 0x30,0x48,0x3A,0x06,0x0E,
    0x26,0x29,0x79,0x29,0x26, 0x40,0x7F,0x05,0x05,0x07, 0x40,0x7F,0x05,0x25,0x3F, 0x5A,0x3C,0xE7,0x3C,0x5A,
    0x7F,0x3E,0x1C,0x1C,0x08, 0x08,0x1C,0x1C,0x3E,0x7F, 0x14,0x22,0x7F,0x22,0x14, 0x5F,0x5F,0x00,0x5F,0x5F,
    0x06,0x09,0x7F,0x01,0x7F, 0x00,0x66,0x89,0x95,0x6A, 0x60,0x60,0x60,0x60,0x60, 0x94,0xA2,0xFF,0xA2,0x94,
    0x08,0x04,0x7E,0x04,0x08, 0x10,0x20,0x7E,0x20,0x10, 0x08,0x08,0x2A,0x1C,0x08, 0x08,0x1C,0x2A,0x08,0x08,
    0x1E,0x10,0x10,0x10,0x10, 0x0C,0x1E,0x0C,0x1E,0x0C, 0x30,0x38,0x3E,0x38,0x30, 0x06,0x0E,0x3E,0x0E,0x06,
    0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x5F,0x00,0x00, 0x00,0x07,0x00,0x07,0x00, 0x14,0x7F,0x14,0x7F,0x14,
    0x24,0x2A,0x7F,0x2A,0x12, 0x23,0x13,0x08,0x64,0x62, 0x36,0x49,0x56,0x20,0x50, 0x00,0x08,0x07,0x03,0x00,
    0x00,0x1C,0x22,0x41,0x00, 0x00,0x41,0x22,0x1C,0x00, 0x2A,0x1C,0x7F,0x1C,0x2A, 0x08,0x08,0x3E,0x08,0x08,
    0x00,0x80,0x70,0x30,0x00, 0x08,0x08,0x08,0x08,0x08, 0x00,0x00,0x60,0x60,0x00, 0x20,0x10,0x08,0x04,0x02,
    0x3E,0x51,0x49,0x45,0x3E, 0x00,0x42,0x7F,0x40,0x00, 0x72,0x49,0x49,0x49,0x46, 0x21,0x41,0x49,0x4D,0x33,
    0x18,0x14,0x12,0x7F,0x10, 0x27,0x45,0x45,0x45,0x39, 0x3C,0x4A,0x49,0x49,0x31, 0x41,0x21,0x11,0x09,0x07,
    0x36,0x49,0x49,0x49,0x36, 0x46,0x49,0x49,0x29,0x1E, 0x00,0x00,0x14,0x00,0x00, 0x00,0x40,0x34,0x00,0x00,
    0x00,0x08,0x14,0x22,0x41, 0x14,0x14,0x14,0x14,0x14, 0x00,0x41,0x22,0x14,0x08, 0x02,0x01,0x59,0x09,0x06,
    0x3E,0x41,0x5D,0x59,0x4E, 0x7C,0x12,0x11,0x12,0x7C, 0x7F,0x49,0x49,0x49,0x36, 0x3E,0x41,0x41,0x41,0x22,
    0x7F,0x41,0x41,0x41,0x3E, 0x7F,0x49,0x49,0x49,0x41, 0x7F,0x09,0x09,0x09,0x01, 0x3E,0x41,0x49,0x49,0x7A,
    0x7F,0x08,0x08,0x08,0x7F, 0x00,0x41,0x7F,0x41,0x00, 0x20,0x40,0x41,0x3F,0x01, 0x7F,0x08,0x14,0x22,0x41,
    0x7F,0x40,0x40,0x40,0x40, 0x7F,0x02,0x1C,0x02,0x7F, 0x7F,0x04,0x08,0x10,0x7F, 0x3E,0x41,0x41,0x41,0x3E,
    0x7F,0x09,0x09,0x09,0x06, 0x3E,0x41,0x51,0x21,0x5E, 0x7F,0x09,0x19,0x29,0x46, 0x46,0x49,0x49,0x49,0x31,
    0x01,0x01,0x7F,0x01,0x01, 0x3F,0x40,0x40,0x40,0x3F, 0x1F,0x20,0x40,0x20,0x1F, 0x3F,0x40,0x38,0x40,0x3F,
    0x63,0x14,0x08,0x14,0x63, 0x07,0x08,0x70,0x08,0x07, 0x61,0x51,0x49,0x45,0x43, 0x00,0x7F,0x41,0x41,0x00,
    0x02,0x04,0x08,0x10,0x20, 0x00,0x41,0x41,0x7F,0x00, 0x04,0x02,0x01,0x02,0x04, 0x40,0x40,0x40,0x40,0x40,
    0x00,0x03,0x07,0x08,0x00, 0x20,0x54,0x54,0x78,0x40, 0x7F,0x28,0x44,0x44,0x38, 0x38,0x44,0x44,0x44,0x28,
    0x38,0x44,0x44,0x28,0x7F, 0x38,0x54,0x54,0x54,0x18, 0x08,0x7E,0x09,0x01,0x02, 0x08,0x14,0x54,0x54,0x3C,
    0x7F,0x08,0x04,0x04,0x78, 0x00,0x44,0x7D,0x40,0x00, 0x20,0x40,0x40,0x3D,0x00, 0x7F,0x10,0x28,0x44,0x00,
    0x00,0x41,0x7F,0x40,0x00, 0x7C,0x04,0x78,0x04,0x78, 0x7C,0x08,0x04,0x04,0x78, 0x38,0x44,0x44,0x44,0x38,
    0x7C,0x14,0x14,0x14,0x08, 0x08,0x14,0x14,0x18,0x7C, 0x7C,0x08,0x04,0x04,0x08, 0x48,0x54,0x54,0x54,0x20,
    0x04,0x3F,0x44,0x40,0x20, 0x3C,0x40,0x40,0x20,0x7C, 0x1C,0x20,0x40,0x20,0x1C, 0x3C,0x40,0x30,0x40,0x3C,
    0x44,0x28,0x10,0x28,0x44, 0x0C,0x50,0x50,0x50,0x3C, 0x44,0x64,0x54,0x4C,0x44, 0x00,0x08,0x36,0x41,0x00,
    0x00,0x00,0x77,0x00,0x00, 0x00,0x41,0x36,0x08,0x00, 0x02,0x01,0x02,0x04,0x02, 0x3C,0x26,0x23,0x26,0x3C
};

// 低级 SPI 写
static void ILI9341_WriteCommand(uint8_t cmd)
{
    LCD_DC_LOW();
    LCD_CS_LOW();
    HAL_SPI_Transmit(&hspi1, &cmd, 1, HAL_MAX_DELAY);
    LCD_CS_HIGH();
}

static void ILI9341_WriteData8(uint8_t data)
{
    LCD_DC_HIGH();
    LCD_CS_LOW();
    HAL_SPI_Transmit(&hspi1, &data, 1, HAL_MAX_DELAY);
    LCD_CS_HIGH();
}

static void ILI9341_WriteData16(uint16_t data)
{
    uint8_t buf[2] = { data >> 8, data & 0xFF };
    LCD_DC_HIGH();
    LCD_CS_LOW();
    HAL_SPI_Transmit(&hspi1, buf, 2, HAL_MAX_DELAY);
    LCD_CS_HIGH();
}

static void ILI9341_SetAddressWindow(uint16_t x0, uint16_t y0,
                                     uint16_t x1, uint16_t y1)
{
    // Column addr set
    ILI9341_WriteCommand(0x2A);
    ILI9341_WriteData16(x0);
    ILI9341_WriteData16(x1);

    // Row addr set
    ILI9341_WriteCommand(0x2B);
    ILI9341_WriteData16(y0);
    ILI9341_WriteData16(y1);

    // Write to RAM
    ILI9341_WriteCommand(0x2C);
}

void ILI9341_DrawPixel(uint16_t x, uint16_t y, uint16_t color)
{
    if (x >= _width || y >= _height) return;
    ILI9341_SetAddressWindow(x, y, x, y);
    ILI9341_WriteData16(color);
}

void ILI9341_DrawHLine(uint16_t x, uint16_t y, uint16_t w, uint16_t color)
{
    if (y >= _height) return;
    if (x + w > _width) w = _width - x;

    ILI9341_SetAddressWindow(x, y, x + w - 1, y);

    LCD_DC_HIGH();
    LCD_CS_LOW();
    for (uint16_t i = 0; i < w; i++) {
        uint8_t buf[2] = { color >> 8, color & 0xFF };
        HAL_SPI_Transmit(&hspi1, buf, 2, HAL_MAX_DELAY);
    }
    LCD_CS_HIGH();
}

void ILI9341_FillScreen(uint16_t color)
{
    ILI9341_SetAddressWindow(0, 0, _width - 1, _height - 1);

    LCD_DC_HIGH();
    LCD_CS_LOW();
    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;
    for (uint32_t i = 0; i < (uint32_t)_width * _height; i++) {
        uint8_t buf[2] = { hi, lo };
        HAL_SPI_Transmit(&hspi1, buf, 2, HAL_MAX_DELAY);
    }
    LCD_CS_HIGH();
}

void ILI9341_FillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h, uint16_t color)
{
    if (x >= _width || y >= _height) return;
    if (x + w > _width)  w = _width - x;
    if (y + h > _height) h = _height - y;
    ILI9341_SetAddressWindow(x, y, x + w - 1, y + h - 1);

    LCD_DC_HIGH();
    LCD_CS_LOW();
    uint8_t hi = color >> 8;
    uint8_t lo = color & 0xFF;
    uint32_t pixels = (uint32_t)w * h;
    while (pixels--) {
        uint8_t buf[2] = { hi, lo };
        HAL_SPI_Transmit(&hspi1, buf, 2, HAL_MAX_DELAY);
    }
    LCD_CS_HIGH();
}

void ILI9341_SetRotation(uint8_t m)
{
    ILI9341_WriteCommand(0x36);
    uint8_t data = 0;

    switch (m & 3) {
    case 0: data = 0x48; _width = 240; _height = 320; break; // 竖屏
    case 1: data = 0x28; _width = 320; _height = 240; break; // 横屏
    case 2: data = 0x88; _width = 240; _height = 320; break;
    case 3: data = 0xE8; _width = 320; _height = 240; break;
    }
    ILI9341_WriteData8(data);
}

// 非完整、但足够用的初始化序列（可按自己屏幕资料微调）
void ILI9341_Init(void)
{
    // 硬件复位
    LCD_RST_LOW();
    HAL_Delay(20);
    LCD_RST_HIGH();
    HAL_Delay(120);

    // Power control 等初始化（简化版）
    ILI9341_WriteCommand(0x01); // Software reset
    HAL_Delay(120);

    ILI9341_WriteCommand(0x28); // Display OFF

    ILI9341_WriteCommand(0xCF);
    ILI9341_WriteData8(0x00);
    ILI9341_WriteData8(0x83);
    ILI9341_WriteData8(0x30);

    ILI9341_WriteCommand(0xED);
    ILI9341_WriteData8(0x64);
    ILI9341_WriteData8(0x03);
    ILI9341_WriteData8(0x12);
    ILI9341_WriteData8(0x81);

    ILI9341_WriteCommand(0xE8);
    ILI9341_WriteData8(0x85);
    ILI9341_WriteData8(0x01);
    ILI9341_WriteData8(0x79);

    ILI9341_WriteCommand(0xCB);
    ILI9341_WriteData8(0x39);
    ILI9341_WriteData8(0x2C);
    ILI9341_WriteData8(0x00);
    ILI9341_WriteData8(0x34);
    ILI9341_WriteData8(0x02);

    ILI9341_WriteCommand(0xF7);
    ILI9341_WriteData8(0x20);

    ILI9341_WriteCommand(0xEA);
    ILI9341_WriteData8(0x00);
    ILI9341_WriteData8(0x00);

    // 像素格式
    ILI9341_WriteCommand(0x3A);
    ILI9341_WriteData8(0x55); // 16bit

    // 退出睡眠、打开显示
    ILI9341_WriteCommand(0x11); // Sleep Out
    HAL_Delay(120);
    ILI9341_WriteCommand(0x29); // Display ON

    ILI9341_SetRotation(1);     // 横屏 320x240
    ILI9341_FillScreen(ILI9341_BLACK);
}

static void ILI9341_DrawPixelBlock(uint16_t x, uint16_t y, uint8_t size,
                                   uint16_t color)
{
    if (size == 1) {
        ILI9341_DrawPixel(x, y, color);
    } else {
        ILI9341_FillRect(x, y, size, size, color);
    }
}

void ILI9341_DrawChar(uint16_t x, uint16_t y, char c,
                      uint16_t color, uint16_t bg, uint8_t size)
{
    uint8_t uc = (uint8_t)c;
    if (uc < 0x20 || uc > 0x7F) {
        uc = '?';
    }
    const uint8_t *glyph = &font5x7[uc * 5];
    for (uint8_t col = 0; col < 5; col++) {
        uint8_t line = glyph[col];
        for (uint8_t row = 0; row < 8; row++) {
            uint16_t drawX = x + col * size;
            uint16_t drawY = y + row * size;
            if (line & 0x1) {
                ILI9341_DrawPixelBlock(drawX, drawY, size, color);
            } else if (bg != color) {
                ILI9341_DrawPixelBlock(drawX, drawY, size, bg);
            }
            line >>= 1U;
        }
    }
    // 竖直方向空一列作为字符间距
    uint16_t spacerX = x + 5 * size;
    for (uint8_t row = 0; row < 8 * size; row++) {
        ILI9341_DrawPixelBlock(spacerX, y + row, size, bg);
    }
}

void ILI9341_DrawString(uint16_t x, uint16_t y, const char *str,
                        uint16_t color, uint16_t bg, uint8_t size)
{
    uint16_t cursor_x = x;
    while (*str) {
        if (*str == '\n') {
            cursor_x = x;
            y += (8 * size);
            str++;
            continue;
        }
        ILI9341_DrawChar(cursor_x, y, *str, color, bg, size);
        cursor_x += 6 * size;
        str++;
    }
}


